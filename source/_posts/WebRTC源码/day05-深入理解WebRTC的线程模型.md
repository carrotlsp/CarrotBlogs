---

title: day05-深入理解WebRTC的线程模型
categories:
  - WebRTC源码
tags:
  - WebRTC
date: 2022-08-15 20:41:31
---



## 一、线程的基础知识 

### 1、本章主要内容



![image-20220815071212363](day05-深入理解WebRTC的线程模型/image-20220815071212363.png)

![image-20220815071220431](day05-深入理解WebRTC的线程模型/image-20220815071220431.png)

### 2、计算机组成原理

![image-20220815073252208](day05-深入理解WebRTC的线程模型/image-20220815073252208.png)

![image-20220815073337468](day05-深入理解WebRTC的线程模型/image-20220815073337468.png)

![image-20220815073343926](day05-深入理解WebRTC的线程模型/image-20220815073343926.png)

### 3、多线程的好处与坏处？多线程带了哪些问题？

![image-20220815073405375](day05-深入理解WebRTC的线程模型/image-20220815073405375.png)

![image-20220815073441593](day05-深入理解WebRTC的线程模型/image-20220815073441593.png)

### 4、如何解决多线程带来的问题？

- 加锁

![image-20220815073513306](day05-深入理解WebRTC的线程模型/image-20220815073513306.png)

### 5、Objective-C和WebRTC中的线程模型是什么？

- 休眠唤醒循环执行任务线程模型

![image-20220815073648293](day05-深入理解WebRTC的线程模型/image-20220815073648293.png)

## 二、WebRTC中的线程模型

### 1、认识Thread类？

- crit_：是临界区，是防止存取或读取数据时发生<font color="red">错乱</font>

![image-20220815073744344](day05-深入理解WebRTC的线程模型/image-20220815073744344.png)



![image-20220815073752486](day05-深入理解WebRTC的线程模型/image-20220815073752486.png)



### 2、关于 Thread的几个要点？

- WebRTC中的线程是<font color="red">以事件驱动的</font>
- <font color="red">事件驱动</font>比<font color="red">轮询</font>的方式，效率高很多

![image-20220815074100020](day05-深入理解WebRTC的线程模型/image-20220815074100020.png)

![image-20220815074110825](day05-深入理解WebRTC的线程模型/image-20220815074110825.png)

### 3、WebRTC中 Thead 类到底长什么样？

![image-20220815074218528](day05-深入理解WebRTC的线程模型/image-20220815074218528.png)

![image-20220815074227838](day05-深入理解WebRTC的线程模型/image-20220815074227838.png)

![image-20220815074237035](day05-深入理解WebRTC的线程模型/image-20220815074237035.png)

![image-20220815074243689](day05-深入理解WebRTC的线程模型/image-20220815074243689.png)



> Thread类是非常庞杂的，总结起来Thread类就包含三大部分，理解这个<font color="red">非常重要</font>，不然就会面对Thread一脸懵逼

- 一大类是与队列相关的
- 一大类是与事件相关的
- 一大类是与线程相关的



### 4、认识线程管理类，ThreadManager类【重要】

- 以下的图，对理解ThreadManager起到了至关重要的作用

![image-20220815074533549](day05-深入理解WebRTC的线程模型/image-20220815074533549.png)

![image-20220815074543208](day05-深入理解WebRTC的线程模型/image-20220815074543208.png)

### 5、认识thread local storage

![image-20220815074627969](day05-深入理解WebRTC的线程模型/image-20220815074627969.png)

### 6、源码阅读，理解ThreadManager 和 thread local storage

![image-20220815074643232](day05-深入理解WebRTC的线程模型/image-20220815074643232.png)

![image-20220815074649491](day05-深入理解WebRTC的线程模型/image-20220815074649491.png)

![image-20220815074701954](day05-深入理解WebRTC的线程模型/image-20220815074701954.png)



### 7、WebRTC的所有线程都是由三大线程创建的，那么WebRTC的三大线程分别是哪些呢？

![image-20220815074734300](day05-深入理解WebRTC的线程模型/image-20220815074734300.png)

### 8、从代码中查看并熟悉这三个线程？

![image-20220815074745533](day05-深入理解WebRTC的线程模型/image-20220815074745533.png)

![image-20220815074757999](day05-深入理解WebRTC的线程模型/image-20220815074757999.png)

![image-20220815074809579](day05-深入理解WebRTC的线程模型/image-20220815074809579.png)



![image-20220815074818282](day05-深入理解WebRTC的线程模型/image-20220815074818282.png)

![image-20220815074827167](day05-深入理解WebRTC的线程模型/image-20220815074827167.png)



- 从上图可知，WebRTC把当前线程当成了信令线程
- 跟进去看看

![image-20220815074850334](day05-深入理解WebRTC的线程模型/image-20220815074850334.png)

![image-20220815074858564](day05-深入理解WebRTC的线程模型/image-20220815074858564.png)

![image-20220815074905954](day05-深入理解WebRTC的线程模型/image-20220815074905954.png)



## 三、WebRTC中的线程：线程运行、接口宏

### 1、WebRTC是跨平台的，那么它在Windows和mac上创建线程的实现方式有什么不同呢？

![image-20220815074943317](day05-深入理解WebRTC的线程模型/image-20220815074943317.png)

- 以上是win平台的线程创建的代码

![image-20220815074956662](day05-深入理解WebRTC的线程模型/image-20220815074956662.png)

- 以上是mac平台下创建线程的代码

### 2、三大线程运行的基本逻辑【重要】

![image-20220815075021348](day05-深入理解WebRTC的线程模型/image-20220815075021348.png)



### 3、从实际代码的角度，理解上面两点知识点

![image-20220815075040204](day05-深入理解WebRTC的线程模型/image-20220815075040204.png)



- 我们创建的线程对象，什么时候与我们的线程进行绑定的呢？
- 就是下面这个时机（也就是ThreadManager和Thread绑定时机）

![image-20220815075114194](day05-深入理解WebRTC的线程模型/image-20220815075114194.png)

- 一定是在这个线程已经启动，执行线程函数的时候才进行绑定的



![image-20220815075150133](day05-深入理解WebRTC的线程模型/image-20220815075150133.png)

- 以上我们看到了经典的while(true)循环，也就是线程的执行逻辑



### 4、不同平台处理事件的API？

![image-20220815075205347](day05-深入理解WebRTC的线程模型/image-20220815075205347.png)

![image-20220815075216615](day05-深入理解WebRTC的线程模型/image-20220815075216615.png)

![image-20220815075224169](day05-深入理解WebRTC的线程模型/image-20220815075224169.png)

![image-20220815075232378](day05-深入理解WebRTC的线程模型/image-20220815075232378.png)

### 5、对上面的知识进行小结，小结的内容要掌握一下。



![image-20220815075258232](day05-深入理解WebRTC的线程模型/image-20220815075258232.png)

## 三、WebRTC线程事件处理

### 1、事件是如何协调线程工作的呢？

![image-20220816063424033](day05-深入理解WebRTC的线程模型/image-20220816063424033.png)

![image-20220816063433125](day05-深入理解WebRTC的线程模型/image-20220816063433125.png)

![image-20220816063441254](day05-深入理解WebRTC的线程模型/image-20220816063441254.png)

### 2、认识Get函数

![image-20220816063503528](day05-深入理解WebRTC的线程模型/image-20220816063503528.png)



### 3、认识Get函数中的wait函数？

![image-20220816063536578](day05-深入理解WebRTC的线程模型/image-20220816063536578.png)



## 四、接口宏

### 1、WebRTC中常见的接口，都是借助接口宏实现的

![image-20220816063633745](day05-深入理解WebRTC的线程模型/image-20220816063633745.png)

![image-20220816063648849](day05-深入理解WebRTC的线程模型/image-20220816063648849.png)





![image-20220816063700441](day05-深入理解WebRTC的线程模型/image-20220816063700441.png)

### 2、实现自定义接口

![image-20220816063725960](day05-深入理解WebRTC的线程模型/image-20220816063725960.png)

![image-20220816063734349](day05-深入理解WebRTC的线程模型/image-20220816063734349.png)

![image-20220816063746584](day05-深入理解WebRTC的线程模型/image-20220816063746584.png)

### 3、思考为什么WebRTC要把接口设计得这么复杂？

- 代理层将【应用层】和【WebRTC核心库】做了一层隔离

![image-20220816063826434](day05-深入理解WebRTC的线程模型/image-20220816063826434.png)

### 4、思考WebRTC这样隔离有什么好处呢？

![image-20220816063908231](day05-深入理解WebRTC的线程模型/image-20220816063908231.png)

### 5、接口类关系图，这些图要学会来画

![image-20220816063931784](day05-深入理解WebRTC的线程模型/image-20220816063931784.png)





### 6、观察PeerConnectionFactory这个宏展开的样子，从而理解接口宏

![image-20220816063954882](day05-深入理解WebRTC的线程模型/image-20220816063954882.png)

![image-20220816064005700](day05-深入理解WebRTC的线程模型/image-20220816064005700.png)

### 7、WebRTC接口调用过程？

- 为什么能搞出这么厉害的图
- 太强了，一定要学会来



![image-20220816064025336](day05-深入理解WebRTC的线程模型/image-20220816064025336.png)

### 8、结合实际代码进行分析和链路跟踪

- 首先找到两个重要的宏
- BEGIN_GINALING_PROXY_MAP
- BEGIN_PROXY_MAP

![image-20220816064120677](day05-深入理解WebRTC的线程模型/image-20220816064120677.png)

- 再看RPOXY_MAP_BOILERPLATE这个宏
- 定义了宏的名字，还有别名

![image-20220816064151719](day05-深入理解WebRTC的线程模型/image-20220816064151719.png)

- 再看WORKER_PROXY_MAP_BOILERPLATE 这个宏
- 主要是处理构造函数

![image-20220816064210666](day05-深入理解WebRTC的线程模型/image-20220816064210666.png)

- 再看第三个子宏，REFCOUNTED_PROXY_MAP_BOILERPLATE
- 这个宏用于析构函数的定义

![image-20220816064224778](day05-深入理解WebRTC的线程模型/image-20220816064224778.png)

- END_ROXY_MAP，只定义了一个类花括号的结束，这个很好理解

![image-20220816064236941](day05-深入理解WebRTC的线程模型/image-20220816064236941.png)

- PROXY_METHOD0 ，最后一个数字代表参数格式，这个宏主要用于定义方法

![image-20220816064247355](day05-深入理解WebRTC的线程模型/image-20220816064247355.png)

### 9、思考：我们从应用层调用到WebRTC的核心层，需要经过这么漫长的过程，大概11步，会不会影响WebRTC的调用效率呢？

- 其实不会，因为经过WebRTC的优化，实际上只要经过两三个步骤，就调用到了WebRTC的核心层



### 10、在宏定义的学习过程中，我们看到post方法，该方法主要作用是什么呢？

- post方法：进行线程的切换

![image-20220816064320874](day05-深入理解WebRTC的线程模型/image-20220816064320874.png)

### 11、在WebRTC中线程切换主要有哪些方法？

![image-20220816064330644](day05-深入理解WebRTC的线程模型/image-20220816064330644.png)

- post和postTask是异步调用
- send和invoke 是同步调用

### 12、学习post方法的细节

![image-20220816064351368](day05-深入理解WebRTC的线程模型/image-20220816064351368.png)

![image-20220816064355736](day05-深入理解WebRTC的线程模型/image-20220816064355736.png)

![image-20220816064359257](day05-深入理解WebRTC的线程模型/image-20220816064359257.png)

![image-20220816064404509](day05-深入理解WebRTC的线程模型/image-20220816064404509.png)
